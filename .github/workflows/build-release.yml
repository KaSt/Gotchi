name: Build and Release Firmware

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      version_override:
        description: 'Override version (leave empty to use VERSION file)'
        required: false
        type: string

jobs:
  prepare-release:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      commit_hash: ${{ steps.version.outputs.commit_hash }}
      release_notes: ${{ steps.changelog.outputs.changelog }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Read version and prepare metadata
        id: version
        run: |
          if [ -n "${{ github.event.inputs.version_override }}" ]; then
            VERSION="${{ github.event.inputs.version_override }}"
          else
            VERSION=$(cat VERSION | tr -d '\n\r')
          fi
          COMMIT_HASH=$(git rev-parse --short HEAD)
          TAG="v${VERSION}"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "commit_hash=${COMMIT_HASH}" >> $GITHUB_OUTPUT
          echo "Version: ${VERSION}"
          echo "Tag: ${TAG}"
          echo "Commit: ${COMMIT_HASH}"

      - name: Generate changelog
        id: changelog
        run: |
          # Get the latest tag (if exists)
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LATEST_TAG" ]; then
            echo "No previous release found, generating full changelog"
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" --no-merges -20)
          else
            echo "Generating changelog since ${LATEST_TAG}"
            CHANGELOG=$(git log ${LATEST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          fi
          
          # Create release notes
          RELEASE_NOTES="## Gotchi Firmware v${{ steps.version.outputs.version }}

**Build:** \\\`${{ steps.version.outputs.commit_hash }}\\\`
**Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")

### Changes

${CHANGELOG}

### Supported Devices

#### M5Stack
- M5Stack Cardputer (ESP32-S3, 240x135, keyboard) â­ **Recommended**
- M5StickC Plus2 (ESP32-PICO, 240x135, buttons)
- M5Atom S3 / S3R (ESP32-S3, 128x128, touch)
- M5Stack Core / Core2 / CoreS3 (320x240 displays)
- M5Stack Fire, Paper, and more

#### LilyGo
- T-Display S3 (ESP32-S3, 320x170)
- T-Display (ESP32, 240x135)
- T-Watch S3, T-Embed, T-Dongle S3, T-QT Pro

#### Heltec & Generic
- Heltec WiFi LoRa 32 V3 (with LoRa radio)
- ESP32-S3-DevKitC-1, ESP32-C3-DevKitM-1

### Installation

**Option 1: Web Flasher (Recommended)**
Visit [https://kast.github.io/Atomgotchi/flasher/](https://kast.github.io/Atomgotchi/flasher/) to flash directly from your browser using Chrome/Edge.

**Option 2: Manual Flash**
\`\`\`bash
# Download the firmware for your device
# Flash using esptool.py
esptool.py --chip esp32s3 --port /dev/ttyUSB0 write_flash 0x0 firmware.bin
\`\`\`

**Option 3: PlatformIO**
\`\`\`bash
git clone https://github.com/KaSt/Atomgotchi.git
cd Atomgotchi
pio run -e m5stack-cardputer -t upload
\`\`\`

### Notes
- First boot may take longer due to filesystem initialization
- All firmwares include AI Q-Learning and Friendly modes
- GPS and SD card support included (auto-detected)
- See [README.md](https://github.com/KaSt/Atomgotchi) for full documentation"

          # Save to file and output
          echo "$RELEASE_NOTES" > release_notes.md
          cat release_notes.md
          
          # For GitHub output, we need to handle multiline
          {
            echo 'changelog<<EOF'
            echo "$RELEASE_NOTES"
            echo EOF
          } >> $GITHUB_OUTPUT

      - name: Upload release notes
        uses: actions/upload-artifact@v4
        with:
          name: release-notes
          path: release_notes.md

  build-firmware:
    runs-on: ubuntu-latest
    needs: prepare-release
    strategy:
      matrix:
        board:
          # M5Stack devices
          - { name: "m5stack-cardputer", display: "M5Stack Cardputer", chip: "esp32s3" }
          - { name: "m5stick-c-plus2", display: "M5StickC Plus2", chip: "esp32" }
          - { name: "m5stack-atoms3", display: "M5Atom S3", chip: "esp32s3" }
          - { name: "m5stack-atoms3r", display: "M5Atom S3R", chip: "esp32s3" }
          - { name: "m5stack-core-esp32", display: "M5Stack Core", chip: "esp32" }
          - { name: "m5stack-core2", display: "M5Stack Core2", chip: "esp32" }
          - { name: "m5stack-cores3", display: "M5Stack CoreS3", chip: "esp32s3" }
          # LilyGo devices
          - { name: "lilygo-t-display-s3", display: "LilyGo T-Display S3", chip: "esp32s3" }
          - { name: "lilygo-t-display", display: "LilyGo T-Display", chip: "esp32" }
          - { name: "lilygo-t-embed", display: "LilyGo T-Embed", chip: "esp32s3" }
          # Heltec devices
          - { name: "heltec-wifi-lora-32-v3", display: "Heltec WiFi LoRa 32 V3", chip: "esp32s3" }

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cache PlatformIO
        uses: actions/cache@v4
        with:
          path: |
            ~/.platformio
            .pio
          key: ${{ runner.os }}-pio-${{ hashFiles('platformio.ini') }}
          restore-keys: |
            ${{ runner.os }}-pio-

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install PlatformIO
        run: |
          pip install --upgrade platformio
          pio --version

      - name: Build firmware for ${{ matrix.board.display }}
        run: |
          echo "Building for ${{ matrix.board.name }}"
          pio run -e ${{ matrix.board.name }}

      - name: Prepare firmware files
        run: |
          VERSION="${{ needs.prepare-release.outputs.version }}"
          COMMIT="${{ needs.prepare-release.outputs.commit_hash }}"
          BOARD="${{ matrix.board.name }}"
          
          # Find the built firmware
          FIRMWARE_PATH=$(find .pio/build/${{ matrix.board.name }} -name "firmware.bin" | head -n 1)
          BOOTLOADER_PATH=$(find .pio/build/${{ matrix.board.name }} -name "bootloader.bin" | head -n 1)
          PARTITIONS_PATH=$(find .pio/build/${{ matrix.board.name }} -name "partitions.bin" | head -n 1)
          
          if [ ! -f "$FIRMWARE_PATH" ]; then
            echo "Error: firmware.bin not found!"
            exit 1
          fi
          
          # Create output directory
          mkdir -p firmware-output
          
          # Copy and rename firmware with version and commit hash
          cp "$FIRMWARE_PATH" "firmware-output/gotchi-${BOARD}-${VERSION}-${COMMIT}.bin"
          
          # Also create a "latest" symlink name for web flasher
          cp "$FIRMWARE_PATH" "firmware-output/gotchi-${BOARD}-latest.bin"
          
          # Copy bootloader and partitions if they exist
          if [ -f "$BOOTLOADER_PATH" ]; then
            cp "$BOOTLOADER_PATH" "firmware-output/bootloader-${BOARD}.bin"
          fi
          
          if [ -f "$PARTITIONS_PATH" ]; then
            cp "$PARTITIONS_PATH" "firmware-output/partitions-${BOARD}.bin"
          fi
          
          # Create manifest for web flasher
          cat > "firmware-output/manifest-${BOARD}.json" <<EOF
          {
            "name": "Gotchi - ${{ matrix.board.display }}",
            "version": "${VERSION}",
            "commit": "${COMMIT}",
            "board": "${BOARD}",
            "chip": "${{ matrix.board.chip }}",
            "builds": [
              {
                "chipFamily": "${{ matrix.board.chip }}",
                "parts": [
                  {
                    "path": "gotchi-${BOARD}-${VERSION}-${COMMIT}.bin",
                    "offset": 0
                  }
                ]
              }
            ]
          }
          EOF
          
          ls -lh firmware-output/

      - name: Upload firmware artifact
        uses: actions/upload-artifact@v4
        with:
          name: firmware-${{ matrix.board.name }}
          path: firmware-output/

  create-release:
    needs: [prepare-release, build-firmware]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all firmware artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-firmware

      - name: Download release notes
        uses: actions/download-artifact@v4
        with:
          name: release-notes

      - name: Organize firmware files
        run: |
          mkdir -p release-files
          find all-firmware -name "*.bin" -exec cp {} release-files/ \;
          find all-firmware -name "manifest-*.json" -exec cp {} release-files/ \;
          ls -lh release-files/

      - name: Create/Update Git Tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          TAG="${{ needs.prepare-release.outputs.tag }}"
          
          # Delete tag if it exists (for rebuilds)
          git tag -d "$TAG" 2>/dev/null || true
          git push origin ":refs/tags/$TAG" 2>/dev/null || true
          
          # Create new tag
          git tag -a "$TAG" -m "Release $TAG"
          git push origin "$TAG"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.prepare-release.outputs.tag }}
          name: "Gotchi v${{ needs.prepare-release.outputs.version }}"
          body_path: release_notes.md
          files: release-files/*
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  update-web-flasher:
    needs: [prepare-release, create-release]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: gh-pages

      - name: Download all firmware artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-firmware

      - name: Update flasher firmware files
        run: |
          mkdir -p flasher/firmware
          
          # Copy latest firmware files
          find all-firmware -name "gotchi-*-latest.bin" -exec cp {} flasher/firmware/ \;
          find all-firmware -name "manifest-*.json" -exec cp {} flasher/firmware/ \;
          find all-firmware -name "bootloader-*.bin" -exec cp {} flasher/firmware/ \;
          find all-firmware -name "partitions-*.bin" -exec cp {} flasher/firmware/ \;
          
          # Create firmware index
          cat > flasher/firmware/index.json <<EOF
          {
            "version": "${{ needs.prepare-release.outputs.version }}",
            "commit": "${{ needs.prepare-release.outputs.commit_hash }}",
            "updated": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "manifests": $(find flasher/firmware -name "manifest-*.json" -exec basename {} \; | jq -R . | jq -s .)
          }
          EOF
          
          ls -lh flasher/firmware/

      - name: Commit and push to gh-pages
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add flasher/firmware/
          git commit -m "Update firmware to v${{ needs.prepare-release.outputs.version }} (${{ needs.prepare-release.outputs.commit_hash }})" || echo "No changes to commit"
          git push origin gh-pages || echo "Nothing to push"
